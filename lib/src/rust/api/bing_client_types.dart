// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.30.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:get/get_rx/src/rx_types/rx_types.dart';

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class DisplayConfig {
  final bool state;
  final String rootPath;
  final String cookie;
  final int chatListLen;
  final int stopSignalLen;

  const DisplayConfig({
    required this.state,
    required this.rootPath,
    required this.cookie,
    required this.chatListLen,
    required this.stopSignalLen,
  });

  @override
  int get hashCode =>
      state.hashCode ^
      rootPath.hashCode ^
      cookie.hashCode ^
      chatListLen.hashCode ^
      stopSignalLen.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DisplayConfig &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          rootPath == other.rootPath &&
          cookie == other.cookie &&
          chatListLen == other.chatListLen &&
          stopSignalLen == other.stopSignalLen;
}

class WrappedChat {
  final String conversationId;
  RxString chatName;
  final String tone;
  final String updateTimeLocal;
  final List<String> plugins;

  WrappedChat({
    required this.conversationId,
    required this.chatName,
    required this.tone,
    required this.updateTimeLocal,
    required this.plugins,
  });

  @override
  int get hashCode =>
      conversationId.hashCode ^
      chatName.hashCode ^
      tone.hashCode ^
      updateTimeLocal.hashCode ^
      plugins.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WrappedChat &&
          runtimeType == other.runtimeType &&
          conversationId == other.conversationId &&
          chatName == other.chatName &&
          tone == other.tone &&
          updateTimeLocal == other.updateTimeLocal &&
          plugins == other.plugins;
}

class WrappedMsg {
  final String author;
  final String text;

  const WrappedMsg({
    required this.author,
    required this.text,
  });

  @override
  int get hashCode => author.hashCode ^ text.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WrappedMsg &&
          runtimeType == other.runtimeType &&
          author == other.author &&
          text == other.text;
}
